<!DOCTYPE html><html lang="ch-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Linux base | tony</title><meta name="keywords" content="Linux学习"><meta name="author" content="Tony"><meta name="copyright" content="Tony"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Linux基础学习1、使用xshell远程控制Linux首先我们先要启动ubantu的ssh功能： 1sudo service ssh start  如果没有这个ssh软件就需要安装一下，另外还有安装程序升级一下，所以就有了下面两条命令： 12sudo apt-get install openssh-serversudo apt-get update  然后就可以试着打开xshell软件，新建一个">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux base">
<meta property="og:url" content="https://tony-hurry.github.io/tony.github.io/2022/09/11/Linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="tony">
<meta property="og:description" content="Linux基础学习1、使用xshell远程控制Linux首先我们先要启动ubantu的ssh功能： 1sudo service ssh start  如果没有这个ssh软件就需要安装一下，另外还有安装程序升级一下，所以就有了下面两条命令： 12sudo apt-get install openssh-serversudo apt-get update  然后就可以试着打开xshell软件，新建一个">
<meta property="og:locale" content="ch_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//study-images/linux.png">
<meta property="article:published_time" content="2022-09-11T01:52:11.000Z">
<meta property="article:modified_time" content="2022-11-17T06:05:05.815Z">
<meta property="article:author" content="Tony">
<meta property="article:tag" content="Linux学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//study-images/linux.png"><link rel="shortcut icon" href="/tony.github.io/img/favicon.png"><link rel="canonical" href="https://tony-hurry.github.io/tony.github.io/2022/09/11/Linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/tony.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/tony.github.io/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux base',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-17 14:05:05'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/tony.github.io/atom.xml" title="tony" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/tony.github.io/img/head.gif" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/tony.github.io/archives/"><div class="headline">Articles</div><div class="length-num">6</div></a><a href="/tony.github.io/tags/"><div class="headline">Tags</div><div class="length-num">4</div></a><a href="/tony.github.io/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//study-images/linux.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/tony.github.io/">tony</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux base</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-09-11T01:52:11.000Z" title="Created 2022-09-11 09:52:11">2022-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-11-17T06:05:05.815Z" title="Updated 2022-11-17 14:05:05">2022-11-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux base"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Linux基础学习"><a href="#Linux基础学习" class="headerlink" title="Linux基础学习"></a>Linux基础学习</h1><h3 id="1、使用xshell远程控制Linux"><a href="#1、使用xshell远程控制Linux" class="headerlink" title="1、使用xshell远程控制Linux"></a>1、使用xshell远程控制Linux</h3><p>首先我们先要启动ubantu的ssh功能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service ssh start</span><br></pre></td></tr></table></figure>

<p><strong>如果没有这个ssh软件就需要安装一下，另外还有安装程序升级一下</strong>，所以就有了下面两条命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<p>然后就可以试着打开xshell软件，新建一个会话就开始操作了，如果没有，那么就是没有分好ip的问题，到VMware里面的虚拟网络里面火速调整一波，如果可以ping通的话就可以了；</p>
<p>另外，怎么查看ip呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window:</span><br><span class="line">ipconfig</span><br><span class="line">linux: </span><br><span class="line">ifconfig</span><br></pre></td></tr></table></figure>

<p>再来学一手如何快速关机和重启：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">关机：</span><br><span class="line">shutdown -h now</span><br><span class="line">重启：</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>

<p>不得不说，Linux的命令是真的多！</p>
<h3 id="2、Linux基本操作指令"><a href="#2、Linux基本操作指令" class="headerlink" title="2、Linux基本操作指令"></a>2、Linux基本操作指令</h3><p>1、<strong>pwd</strong>：显示当前操作路径；</p>
<p>2、<strong>cd 目标文件夹</strong>：切换到目标文件夹；</p>
<p>3、<strong>ls -l</strong>：凡是由 - 就是一些额外的选项，代表着的是不同的属性，这里是显示详情，当然，这个可以拼接的：</p>
<p><strong>ls -al</strong> ：这个就表示显示当前目录下所有文件的详细信息；</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//study-images/linux01.png" alt="image-20220912215217937" style="zoom:50%;" />

<p>4、<strong>cp 文件夹 文件夹名</strong>：这是常见的复制文件的命令，当然我们是可以将路径添加上去的，就表明需要复制文件到想要的路径下面；</p>
<p>5、<strong>rm 文件&#x2F;文件夹  -ri</strong>：当然，你们也可以不用加i,那么删除的时候就不会征求你的同意了，所以要慎用；如果是删除文件的话可以不用加选项条件，如果是文件夹的话就需要了；</p>
<p>6、<strong>touch 文件</strong>：这个就是创建文件了；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//study-images/linux02.png" alt="image-20220912220024313"></p>
<p>7、<strong>grep 关键词 文件名</strong>：当然也是可以加上路径的，这个的作用就是查找抓取一定的内容，就根据我们给的关键词来查找；</p>
<p>8、<strong>man 指令</strong>：这个命令比较重要，是用来查找指令的指令手册，如果我们忘记了指令的用法可以依靠他来回忆；</p>
<p>9、使用ctrl+l来清屏，或者输入clear；</p>
<p>10、<strong>mv 文件 文件名</strong>：这个是用来移动和重名命文件的，如果是重命名的话，我们路径可以填.&#x2F;，只填路径；</p>
<h3 id="3、权限常识"><a href="#3、权限常识" class="headerlink" title="3、权限常识"></a>3、权限常识</h3><p>在一个安全性高的系统里面，搞清楚我们具有哪些权限非常重要，Linux里面具有很多权限，当然也可以修改它：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//study-images/linux03.png" alt="image-20220912214421984" style="zoom: 67%;" />

<p>可以看到我这个目录下面的文件夹和文件前面由一些rwx组成的字符串，他们代表的是一些权限，<strong>我们可以将他们三个三个分为一组</strong>，前面三个代表的是用户的权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r: 可读 w:可写 d: 代表是文件夹 x: 是一个可执行文件</span><br></pre></td></tr></table></figure>

<p>第一组表示的用户的权限，第二组代表的是用户组的权限，第三组是所有用户的权限；</p>
<p>对于用户组，就是我们将计算机上的用户分了一个组就是了；</p>
<h4 id="1、修改权限"><a href="#1、修改权限" class="headerlink" title="1、修改权限"></a>1、修改权限</h4><p>这些命令的改变也很简单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod u-w test01.text 表示的是删除用户的可写权限</span><br><span class="line">chmod g+w test01.text 表示的是添加用户组的可写权限</span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//study-images/limux04.png" alt="image-20220912220230133" style="zoom:67%;" />

<p>可以看到输入命令之后test01.text问价的权限发生响应的变化；</p>
<h3 id="4、vi编辑器的使用"><a href="#4、vi编辑器的使用" class="headerlink" title="4、vi编辑器的使用"></a>4、vi编辑器的使用</h3><h4 id="1、编辑"><a href="#1、编辑" class="headerlink" title="1、编辑"></a>1、编辑</h4><p>在Linux中，一般使用vi编辑器来编辑文本文件或者是C语言文件等，那么要怎么操作呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi hello.c</span><br></pre></td></tr></table></figure>

<p>在命令行输入这个命令就可以创建一个c文件，当然不同的文件只是后缀不同；</p>
<p>回车之后就会进入一个文本的编辑界面：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171401082.png" alt="image-20220926200113729" style="zoom:50%;" />

<p>这个编辑器有三种模式，现在这种输入命令行，我们可以输入i来进去插入模式，输入冒号进入底行模式，注意三种模式之间是不能直接转化的，需要通过命令行模式这个跳板才可以转换；</p>
<p>我们试着来写一个简单的c程序：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171401399.png" alt="image-20220926200420270" style="zoom:50%;" />

<p>输入i之后就可以写程序了，比较简单，我们就主要来学习一下命令行模式：</p>
<p>按esc来切换到命令行模式：</p>
<p>然后可以输入一下命令来进行需要的操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x --删除光标所在的字符</span><br><span class="line">dd --删除光标所在行</span><br><span class="line">n+dd --删除包括光标所在的后面n行</span><br><span class="line">d+$ --重光标到尾所有内容全删除</span><br></pre></td></tr></table></figure>

<p>还有就是复制和粘贴：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220926201335860.png" alt="image-20220926201335860" style="zoom:50%;" />

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yy --复制光标所在行</span><br><span class="line">p --粘贴复制的内容到下一行</span><br></pre></td></tr></table></figure>

<p>我们还可以输入o来向下新起一行来进入编辑模式；</p>
<p>底行模式下面的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:w --保存</span><br><span class="line">:q --退出</span><br><span class="line">:x 保存并退出</span><br><span class="line">:wq 同上</span><br></pre></td></tr></table></figure>

<p>另外我们在这些命令的后面添加！就表示强制的进行操作；还有就是替换操作：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171401092.png" alt="image-20220926201833969" style="zoom:50%;" />

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/hello/hi/g --将hello全部替换为hi</span><br></pre></td></tr></table></figure>

<p>还可以使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">：/xx --查找xx</span><br></pre></td></tr></table></figure>

<p>在命令行模式下面可以输入G移动到文档的最后一行；</p>
<h4 id="2、编译"><a href="#2、编译" class="headerlink" title="2、编译"></a>2、编译</h4><p>用于嵌入式开发的C语言代码我们要如何进行编译呢？</p>
<p>首先我们保存并退出**:x**</p>
<p>如果不加百分号的话就表示在当前行进行替换；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c -o hello --将C语言文件编译成可执行文件</span><br></pre></td></tr></table></figure>

<p>对于一个C语言文件到执行文件需要执行四个步骤，而且是有顺序的，<strong>预编译-&gt;编译-&gt;汇编-&gt;链接</strong></p>
<p>一般检查错误都是在编译这个环节；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171401718.png" alt="image-20220926202445383"></p>
<p><strong>注意：这里的&#x2F;n打错了，应该是\n;</strong></p>
<h4 id="3、注意"><a href="#3、注意" class="headerlink" title="3、注意"></a>3、注意</h4><p>在vi编辑器中的三种模式，从插入模式到命令行模式点击esc，从命令行模式到底行模式输入：就可以，但是却不可以直接从插入模式到底行模式；	</p>
<p>有时候我们在编译好了文件之后异常退出，之后在进入文件的时候就会弹出异常退出的对话框，而且是每次进入都会，这时候我们需要在当前路径下面找到一个wrap后缀的隐藏文件，将他删除就可以了；</p>
<p>chown命令和chmod命令是不一样的，前者是更改文件的所有者，后者是更改访问权限，会处在选择题中；</p>
<h3 id="5、首次登陆管理员"><a href="#5、首次登陆管理员" class="headerlink" title="5、首次登陆管理员"></a>5、首次登陆管理员</h3><h4 id="1、设置密码"><a href="#1、设置密码" class="headerlink" title="1、设置密码"></a>1、设置密码</h4><p>在装上新的系统之后如果要切换到管理员账号需要先设置一下密码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd root</span><br></pre></td></tr></table></figure>

<p>输入这行命令之后系统就会提示你需要输入当前账号的密码，然后又会提示输入新密码，按照它的步骤来我们就可以登录管理员账号了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su</span><br></pre></td></tr></table></figure>

<h4 id="2、更新vi编辑器"><a href="#2、更新vi编辑器" class="headerlink" title="2、更新vi编辑器"></a>2、更新vi编辑器</h4><p>因为系统预装的是vim-tiny，这个编辑器的功能便不完善，我们需要删除掉重新安装vim-full:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get remove vim</span><br></pre></td></tr></table></figure>

<p>如果在安装过程中出现问题，很可能就是安装程序没有升级，所以我们可以升级一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br></pre></td></tr></table></figure>

<p>然后在执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install vim</span><br></pre></td></tr></table></figure>

<p><strong>注意：如果不是登录的超级管理员账号，请在前面加上sudo</strong></p>
<h3 id="6、调试程序（gdb-的使用"><a href="#6、调试程序（gdb-的使用" class="headerlink" title="6、调试程序（gdb)的使用"></a>6、调试程序（gdb)的使用</h3><p>在我们写好一个程序之后，可以使用cat命令来查看我们的代码：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171401449.png" alt="image-20221010210759548"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat 文件名</span><br></pre></td></tr></table></figure>

<p>如果想要一个程序可以让我们调试，我们需要让这个程序具备调试的信息，如果让编译文件具有调试信息呢？</p>
<p>很简单，只需要在编译的指令后加上一个-g</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171401432.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc mutifytest.c -o mutify -g</span><br></pre></td></tr></table></figure>

<p>可以看到这个编译出来的文件还是比较大的，因为里面存在调试信息；</p>
<p>这是程序编译的结果；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171401513.png" alt="image-20221010210651114"></p>
<p>然后我们使用gdb命令来启动调试：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171401369.png" alt="image-20221010210917906"  />

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb 带有调试信息的可执行文件</span><br></pre></td></tr></table></figure>

<p>在弹出的gdb模式下面我们可以输入下面的常用调试命令来实现我们的调试功能：</p>
<p>1、b + 行号 ： 在行号前面打一个断点</p>
<p>2、r : 开始调试</p>
<p>3、n :  往下执行，不会进入函数</p>
<p>4、step :  往下执行，一步一步执行，会进入函数</p>
<p>5、l :  显示代码十行，如果重复输入，将会往后显示直至代码结束，这个显示数量可以通过set list进行调整：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171401507.png" alt="image-20221010211402817" style="zoom:50%;" />

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171401392.png" alt="image-20221010211549407"></p>
<p>不过需要注意只是当前调试生效，退出之后就无效了；</p>
<p>6、quit : 可以退出调试</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171401578.png" alt="image-20221010211516333"></p>
<p>7、display：可以再调试的时候使用，自动打印当前位置的变量值</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171401932.png" alt="image-20221010211807279"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display 变量值</span><br></pre></td></tr></table></figure>

<p>8、条件断点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b if 条件</span><br></pre></td></tr></table></figure>

<p><strong><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171402198.png" alt="image-20221010212021315"></strong></p>
<p>条件断点也是非常常用的，我们的以设置在变量满足某种情况的时候打个断点；</p>
<p>9、i b : 显示当前所有断点的信息；</p>
<h3 id="7、用户和用户组"><a href="#7、用户和用户组" class="headerlink" title="7、用户和用户组"></a>7、用户和用户组</h3><p>在Linux系统中有三大用户，分别是超级用户、普通用户和系统用户，他们拥有者各自的权限和各自的组，而在用户组中，有又基本组和附加组，一个用户只有一个基本组，但是可以从属于多个附加组，这一节，我们来学习如何创建一个用户和如何更改该用户的分组；</p>
<h4 id="1、创建用户："><a href="#1、创建用户：" class="headerlink" title="1、创建用户："></a>1、创建用户：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd -m wlw（用户名）</span><br><span class="line">sudo adduser wlw</span><br></pre></td></tr></table></figure>

<p>我们需要超级管理员权限才可以创建一个用户，这里我们就使用sudo，当我们执行命令后其实就创建了一个名字叫wlw的用户，但是这个时候并不会在Linux上生成这个账号，因为我们还没有设置密码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd wlw</span><br></pre></td></tr></table></figure>

<p>这是给账户设置密码，同样修改密码也是这个指令，当我们回车之后就会提示我们输入新密码然后再重复一次；设置好密码之后就可以看到有一个新用户在Linux上了：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171402861.png" alt="image-20221017185833355" style="zoom:50%;" />

<p>注意我们在创建用户的时候加上的参数-m ，他的作用就是生成账户对应的文件夹，我们每一个用户都应该有一个自己的文件夹，如果不加这个参数就不会自动创建了；</p>
<h4 id="2、给用户分组"><a href="#2、给用户分组" class="headerlink" title="2、给用户分组"></a>2、给用户分组</h4><p>我们可以使用下面的命令来查看用户的分组情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/group</span><br></pre></td></tr></table></figure>

<p>这个命令可以打印所有用户的分组信息，这里我们刚刚创建的用户信息就是这样的：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171402760.png" alt="image-20221017190840570"></p>
<p>wlw:X:1001</p>
<p>这个告诉我们什么信息呢？第一个是组名，第二个是密码位，第三个是组id；所以说明我们创建用户的时候会创建一个为用户名的用户组，而且这个组为基本组，是不可以删除的，我们还可以将刚刚创建的用户分到附加组，比如这里的tony组，我们切换到超级用户更好操作（su）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">usermod -a -G sy（用户组） wlw（用户名）</span><br></pre></td></tr></table></figure>

<p>使用这个命令我们可以将创建的wlw用户分到sy组中;使用下面到的命令可以实现查看用户组下面所有的用户：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171402221.png" alt="image-20221018090444824"></p>
<h4 id="3、创建一个用户组"><a href="#3、创建一个用户组" class="headerlink" title="3、创建一个用户组"></a>3、创建一个用户组</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd -g 550（id） sy（组名）</span><br></pre></td></tr></table></figure>

<p>使用这个命令可以创建一个用户组，而且他的id为550；</p>
<h4 id="4、权限的修改"><a href="#4、权限的修改" class="headerlink" title="4、权限的修改"></a>4、权限的修改</h4><p>我们之前就说过，关于文件的权限也是跟组有关的，文件的权限有三组：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171402931.png" alt="image-20221017205530673"></p>
<p>他们其实是一串8进制数，也就是每三个没一组，rwx分别对应的数值是421，所以以后我们遇到对应的权限的数字需要知道这个文件拥有的是那些权限，可读对应的是4 ，可写是2，可执行为1；</p>
<p>那我们来修改一下文件所属的组：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171402447.png" alt="image-20221017205844914"></p>
<p>来修改这个文件为例，分清楚这三组分别对应哪三组权限：<strong>第一组表示的用户的权限，第二组代表的是用户组的权限，第三组是所有用户的权限；</strong>这个之前我们就讲过；</p>
<p>这个文件所属的组有两个，一个是tony，一个是sy，我们可以将tony改成wlw组:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R wlw hello*</span><br></pre></td></tr></table></figure>



<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171402385.png" alt="image-20221017210337478"></p>
<p>如果想要看如何修改权限，可以直达：</p>
<h4 id="5、删除用户和用户组"><a href="#5、删除用户和用户组" class="headerlink" title="5、删除用户和用户组"></a>5、删除用户和用户组</h4><p>我们有时候创建错了用户或者用户组可以使用下面的命令进行删除：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel -fr wlw（用户名）</span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171402653.png" alt="image-20221017211027140" style="zoom:50%;" />

<p>-f表示强制删除，-r表示删除用户所创建的文件，也就是我们之前创建用户时自动创建的文件夹；</p>
<p>使用下面的命令来删除用户组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupdel wlw（用户组名）</span><br></pre></td></tr></table></figure>

<h3 id="8、shell基础入门"><a href="#8、shell基础入门" class="headerlink" title="8、shell基础入门"></a>8、shell基础入门</h3><h4 id="1、重定向、管道、连接符和文本分析器（awk）"><a href="#1、重定向、管道、连接符和文本分析器（awk）" class="headerlink" title="1、重定向、管道、连接符和文本分析器（awk）"></a>1、重定向、管道、连接符和文本分析器（awk）</h4><p>那么现在我们开始讲一些比较高级的linux命令了，首先是重定向，什么是重定向？</p>
<p>重定向就是将文件的输入输出重新定义到一个新的位置，<strong>重定向又有三种：输出重定向（&gt;或者&gt;&gt;）、输入重定向（&lt;）、错误重定向（2&gt;或者2&gt;&gt;）。</strong></p>
<p><strong>这里的&gt;&gt; 和 &lt;&lt; 表示的是追加数据，&lt; 和&gt; 表示的是全部替换，</strong>想要了解重定向，我们现需要了解linux的三种输入输入：</p>
<p><strong>标准输入：</strong>输入文件的标号是0，也就是0代表着标准输入，默认的是键盘，在命令执行的时候读取输入文件的数据；</p>
<p><strong>标准输出</strong>：标号为1，默认设备是显示器，命令执行之后将其输入结果发送到标准的输出文件；</p>
<p><strong>标准错误：</strong>标号为2，默认设备也是显示器，命令执行之后将错误信息发送到标准错误文件；</p>
<p>所以这就是为什么错误重定向就是在输入重定向前面加上一个2的原因；</p>
<h5 id="1、输出重定向："><a href="#1、输出重定向：" class="headerlink" title="1、输出重定向："></a>1、输出重定向：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &gt;&gt; 文件名</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171402946.png" alt="image-20221019164109590"></p>
<p>这个命令就是将ls执行之后的结果输出到standard.c文件里面，可以很明显的看到我们当前文件夹下面的文件和文件夹结果就展示在standard.c文件内容中；同样，举一反三，我们如果是ll命令也好，其他具有输出功能的命令也好，都是将结果输出到后面的文件中；</p>
<h5 id="2、输入重定向"><a href="#2、输入重定向" class="headerlink" title="2、输入重定向"></a>2、输入重定向</h5><p>输入重定向就是反过来，我们就可以将某一个文件的内容当成命令的输入，比如一些需要输入的指令，grep,cat：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep pro &lt; 文件名</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171402386.png" alt="image-20221019164854856"></p>
<p>这里就是将standard文件中带有pro字符的内容抓取出来；</p>
<h5 id="3、错误重定向"><a href="#3、错误重定向" class="headerlink" title="3、错误重定向"></a>3、错误重定向</h5><p>这个其实就是抓取错误用的，用法和输出重定向类似，我们首先得有一个错误程序，比如下面的错误代码：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221019165128992.png" alt="image-20221019165128992"></p>
<p>我在lesson01.c文件中写了这样的代码，其实后面没有分号，然后编译时就会报错，我们可以将错误信息输出到standard.c文件中，是使用&gt;&gt;追加输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c 要编译的文件 2&gt; 输出的文件</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171402040.png" alt="image-20221019165415486"></p>
<p>这里可以看到standard.c文件中就多出了编译lesson01.c文件时报的错误信息；</p>
<h5 id="4、管道"><a href="#4、管道" class="headerlink" title="4、管道"></a>4、管道</h5><p>管道使用符号是|，他的作用就是将一个命令的输出作为另一个命令的输入内容，比如我们grep命令和cat命令结合使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat 文件 | grep 关键字</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171402096.png" alt="image-20221019165801702"></p>
<p>这里实现的就是将cat出来的内容作为grep的抓取对象，可以很明显的看到这里输入了一条带有init的记录，其实就是&#x2F;etc&#x2F;passwd中的一条记录；</p>
<h5 id="5、连接符"><a href="#5、连接符" class="headerlink" title="5、连接符"></a>5、连接符</h5><p>连接符有三种：；（分号），&amp;&amp;（逻辑与），||（逻辑或）</p>
<p>分号；：</p>
<p>因为有时候我们想要执行的命令很多，如果我们一条一条执行的话太过繁琐，不如我们一次性写一堆让它自己慢慢执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令1;命令2;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171402564.png" alt="image-20221019170147491"></p>
<p>这个可以接很多命令，但是都是顺序执行的，也就是不管失败与否都会执行一遍；</p>
<p>逻辑与&amp;&amp;：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令1&amp;&amp;命令2</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171402384.png" alt="image-20221019170327966"></p>
<p>这个语句是有判断能力的，只有前面一条语句执行成功之后才会执行后面的，可以看到我们执行ll成功之后还会执行ls，但是执行s失败之后就不会再执行ls了；</p>
<p>逻辑或||：</p>
<p>这个其实就是和逻辑与反过来的，就是之后前面一个失败后面一个才会执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令1 || 命令2</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221019170652119.png" alt="image-20221019170652119"></p>
<p>可以看到当第一条指令执行完成之后并没有执行第二条指令；</p>
<h5 id="6、文本分析器awk"><a href="#6、文本分析器awk" class="headerlink" title="6、文本分析器awk"></a>6、文本分析器awk</h5><p>这个指令和grep类似，都是用来抓取我们想要的数据的，不过这个指令的选项多一些，功能更好、更强大一点，我们来看他的规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F 分隔符 &#x27;条件&#123;printf 列和格式&#125;&#x27; 文件</span><br></pre></td></tr></table></figure>

<p>这里的意思就是我们在一个文件中，他的内容是这样的：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171402647.png" alt="image-20221019171248677"></p>
<p>分隔符的意思就好比我们取文件的界限，比如这里我们可以去空格，如果小明和数学之间是；的话，我们就可以取分号，如果不设置，也就是缺省的话默认就是空格，这样就将第一行的数据分成了三列，也就是小明 、数学和89三列，分别使用$1,$2,$3表示，后面还有数据的话依次类推，条件的话我们可以设置（ $2&#x3D;&#x3D;”数学”），这样的，意思就是筛选出第二列是数学的记录，格式就是我们想要添加的字符样式之类的：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171402205.png" alt="image-20221019171913552"></p>
<p>可以看到这里就输出了我们想要的内容；</p>
<h4 id="2、第一个shell程序"><a href="#2、第一个shell程序" class="headerlink" title="2、第一个shell程序"></a>2、第一个shell程序</h4><p>shell脚本是linux中常用到的纯文本文件，可以用它来执行一些我们想要执行的shell程序，我们在学习之前先来入个门；</p>
<p>创建一个hello.sh文件，在里面输入：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171402808.png" alt="image-20221019172333001"></p>
<p>这里的#就是注释的意思，echo就是答应的意思，date是打印时间，写好文件保存然后可以使用三种方式来执行它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sh 文件名</span><br><span class="line">bash 文件名</span><br><span class="line">./文件名 （前提是需要使用chmod更改文件为可执行文件）</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171402297.png" alt="image-20221019172530895"></p>
<p>一般来说bash要比sh更加常用，因为改变权限太麻烦，而且执行文件的方式又多，这里我就不一一介绍了，感兴趣的小伙伴可以自行尝试；</p>
<h3 id="9、更换输入法"><a href="#9、更换输入法" class="headerlink" title="9、更换输入法"></a>9、更换输入法</h3><p>用户linux的很多小伙伴就知道，linux上的输入法是英文的，而且我们还不知道如何设置成中文，确实也是这样的，因为linux不像win10，直接上网下一个就好了，而且切换输入法的方式也和win10不一样，那么我就来教教大家linux上如何切换输入法为汉语拼音：</p>
<p>1、更改输入法系统</p>
<p>系统默认带了输入法系统，但是这种输入法系统并不支持中文输入，所以我们需要下载一个：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install fcitx</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171402727.png" alt="image-20221022221625656"></p>
<p>这个才是linux常用的输入法系统，也是有很多人喜欢使用它；</p>
<h3 id="10、shell编程基础入门"><a href="#10、shell编程基础入门" class="headerlink" title="10、shell编程基础入门"></a>10、shell编程基础入门</h3><h4 id="1、变量定义"><a href="#1、变量定义" class="headerlink" title="1、变量定义"></a>1、变量定义</h4><p>linux比较喜欢使用脚本语言，也就是shell，具有变量的无特定类型的特点，我们可以不写数据类型就可以进行定义和赋值，他的语句具有镜像的特点，比如if需要以fi结尾，case 要以esac结尾；那我们来走进shell的世界探索一番脚本语言的语法：</p>
<p>shell定义变量也是和C语言一样需要遵循规则的，比如一些不可以用作变量名的字符：标点符号、纯数字、关键字；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171402498.png" alt="image-20221024184155198"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">变量名=值</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">变量名</span></span><br></pre></td></tr></table></figure>

<p>C语言里面如果我们想要引用变量的时候直接写变量名叫就可以了，但是在shell中我们必须要加上$才行；注意空格的问题，在shell中很多时候会出现空格，一定要记住不可以随便删除空格；这里变量赋值的时候千万不要多添加空格，不然的话会报错：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171403470.png" alt="image-20221024184612671"></p>
<p>C语言中有全局变量的定义，shell里面叫做环境变量，有三种定义形式，分别作用于当前线程，当前用户和多用户都可以使用的变量：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export name=变量值</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在~/.bashrc 的最后一行加上上面的语句</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在 /etc/profile 的最后一行加上上面的语句</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171403629.png" alt="image-20221024185218357"></p>
<p>我们可以使用vi编辑器打开对应的文档然后加上这一句就可以了，两个文档都是一样的操作；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171403657.png" alt="image-20221024185338599"></p>
<p>如果我们想要给变量清空赋值的话也比较简单，直接运行:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset 变量名</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171403364.png" alt="image-20221024185945369"></p>
<p>可以看到我们定义了一个变量叫做a，赋值为1，然后执行了一下unset之后就清空了；</p>
<p><strong>数组的定义：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list=(1,2,3,4)</span><br><span class="line"></span><br><span class="line">echo $&#123;list[1]&#125;</span><br></pre></td></tr></table></figure>

<p>第一个就是数组的定义了，后面一个其实就是数组的引用，这里强调一下必须要加的大括号，因为$在不加大括号的情况下只会引用list，而忽略掉[1];<strong>注意这里数组元素之间使用逗号隔开；</strong></p>
<p>我们还可以使用一些shell中的特殊含义的字符，他们也是shell命令：#（个数）、@（所有数量）、$$（当前线程id）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171403166.png" alt="image-20221024192452331"></p>
<p>这里的意思就是打印array所有元素的数量；除了用在数组中，这里的特殊字符还可以使用在位置参数中，也就是我们执行一个脚本文件的时候在后面添加的参数列表：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171403139.png" alt="image-20221025104527790"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash 脚本文件 参数列表</span><br></pre></td></tr></table></figure>

<p>注意我们填写参数列表的时候是使用空格隔开的不是逗号，和数组一样的，然后我们可以是文件里面可以使用$+数字的方式，来引用位置参数，要注意的是我们无法改变这个未知参数的数值；然后就可以使用@表示所有的参数，#表示参数个数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">echo &quot;my name is : sy&quot;</span><br><span class="line">echo &quot;the first subject is : $1&quot;</span><br><span class="line">echo &quot;the seccond subject is : $2&quot;</span><br><span class="line">echo &quot;the third subject is : $3&quot;</span><br><span class="line">echo &quot;the forth subject is : $4&quot;</span><br><span class="line">echo &quot;the all subject subject is : $@ &quot; </span><br><span class="line">echo &quot;the number of subject is : $#&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;input your performance of Math,Chinese,English,Linux: &quot;</span><br><span class="line">read -p &quot;your Math performance is : &quot; Math</span><br><span class="line">read -p &quot;your Chinese performance is : &quot; Chinese</span><br><span class="line">read -p &quot;your English performance is : &quot; English</span><br><span class="line">read -p &quot;your Linux performance is : &quot; Linux</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shift</span><br><span class="line">echo &quot;the all subject subject is : $@ $Math $Chinese $English $Linux &quot;                                                                           </span><br></pre></td></tr></table></figure>

<p><strong>这里有一个shift命令，作用就是将所有的位置参数往左移除一个，注意，移出去了就是用不了了；</strong></p>
<h4 id="2、计算式"><a href="#2、计算式" class="headerlink" title="2、计算式"></a>2、计算式</h4><p>既然是学习编程肯定是需要学习如何使用shell语言进行计算：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">(($</span><span class="language-bash">变量1+$变量2))</span></span><br><span class="line">let c=$变量1+$变量</span><br><span class="line">expr c=$变量1+$变量</span><br></pre></td></tr></table></figure>

<p>这是常见的三种进行计算的方式，可以看得出来，shell里面的计算可不是那么好做；反正变量的引用就需要使用$，计算时还需要加上let 或者是expr，这三种方式其实是等价的，效果一样；我就不过多演示了：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171403840.png" alt="image-20221024190419282"></p>
<p>如果是要计算小数我们得需要另写式子：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171403355.png" alt="image-20221024192657979"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;scale=保留多少位小数; 小数1*小数2&quot;|bc</span><br><span class="line">printf %.保留小数位数f `echo 小数1*小数2|bc`</span><br><span class="line">result=$(echo &quot;scale=保留多少位小数; 小数1*小数2&quot;|bc)</span><br></pre></td></tr></table></figure>

<p>当然这里也可以引用变量小数，只不过不要忘记加上$；第二种其实就是C语言的形式，那种数据的格式化输出；如果我们是要计算出来结果然后赋值给某一个变量的话就需要使用$()或者$[]的方式，在括号里面输入计算的表达式</p>
<h4 id="3、判断语句"><a href="#3、判断语句" class="headerlink" title="3、判断语句"></a>3、判断语句</h4><p>现在我们来看看shell中的if判断语句和一些判断条件如何使用：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171403892.png" alt="image-20221024193751930"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [ $a -lt $b ];then</span><br><span class="line">        echo &quot; a &lt; b&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>注意这[]里面存放的是判断语句，而且空格不能错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-gt 大于号</span><br><span class="line">-ge 大于等于号</span><br><span class="line">-lt 小于号</span><br><span class="line">-le 小于等于号</span><br><span class="line">-eq 返回值比较，相同就真</span><br><span class="line">-nq 不同就真</span><br><span class="line"></span><br><span class="line">str1=str2 字符串比较</span><br><span class="line">str1!=str2 字符串反比</span><br><span class="line">-n str    不为空就真</span><br><span class="line">-z str	  为空就真</span><br></pre></td></tr></table></figure>

<p>这里常用的比较命令，需要记一下；</p>
<p>转义运算符 \ :<br>有时候我们想要输出一些含有特殊含义的命令符号，比如$ , @ 等，不可以直接打印，所以就使用转移运算符就可以了：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171403044.png" alt="image-20221024194422908"></p>
<p>我们还可以使用多分支的判断语句：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">read -p &quot;请输入文件或者文件夹名称：&quot; file</span><br><span class="line">if [ -d $file ];then</span><br><span class="line">        echo -n &quot;$file是一个文件夹&quot;</span><br><span class="line">elif [ -x $file ];then</span><br><span class="line">        echo -n &quot;$file是一个可执行文件&quot;</span><br><span class="line">else</span><br><span class="line">        echo -n &quot;$file是一个普通文件&quot;</span><br><span class="line">fi</span><br><span class="line">echo</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们使用了文件的基本几个判断，-d后面加上文件名是判断是否是一个文件夹，-x是判断可执行文件；注意一个规律，在判断语句的后面一般需要接上then，不要忘记这里的分号，在有循环的语句后面习惯使用do-done来代替C语言里面的大括号；</p>
<h4 id="4、read接受用户输入"><a href="#4、read接受用户输入" class="headerlink" title="4、read接受用户输入"></a>4、read接受用户输入</h4><p>和C语言的scanf的功能一样，等待用户的输入：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171403932.png" alt="image-20221024200423434"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read -p &quot;文字描述&quot; 参数列表</span><br></pre></td></tr></table></figure>

<p>按照这样的格式来写，要求我们输入的时候就是按照参数列表的个数和顺序来输入数据就行了，这里提醒一个，就是echo后面的-n的作用就是清除换行；</p>
<h4 id="5、selecte、case、for、while、until语句的基本使用"><a href="#5、selecte、case、for、while、until语句的基本使用" class="headerlink" title="5、selecte、case、for、while、until语句的基本使用"></a>5、selecte、case、for、while、until语句的基本使用</h4><p>shell中也是有很多有趣的语句，比如开关和循环语句，与C语言不一样的事shell习惯使用do和done来代替大括号：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;What do you want to study?&quot;</span><br><span class="line">select subject in &quot;Adnroid&quot; &quot;Java&quot; &quot;C++&quot; &quot;IOS&quot;</span><br><span class="line">do</span><br><span class="line">	echo &quot;You have selected $subject&quot;</span><br><span class="line">	break</span><br><span class="line">done</span><br><span class="line">exit 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>select其实也是一个循环，只要我们不选择选项中的项就会一直要你选择，这里我们设置了四个选项，它的执行效果比较特殊：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171403423.png" alt="image-20221026131118863"></p>
<p>他会把in后面的参数列表全部列出来，然后要求你去选择，选择之后打印一句话；</p>
<p>case语句其实就是开关语句，也是一种循环的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">echo -n &quot;a:&quot;</span><br><span class="line">read a</span><br><span class="line">echo -n &quot;b:&quot;</span><br><span class="line">read b</span><br><span class="line">echo -n &quot;select(+ - * /):&quot;</span><br><span class="line">read var</span><br><span class="line">case $var in</span><br><span class="line">        &quot;+&quot;)echo &quot;a+b=$[ $a+$b ]&quot;;;</span><br><span class="line">        &quot;-&quot;)echo &quot;a-b=$[ $a-$b ]&quot;;;</span><br><span class="line">        &quot;*&quot;)echo &quot;a*b=$[ $a*$b ]&quot;;;</span><br><span class="line">        &quot;/&quot;)echo &quot;a/b=$[ $a/$b ]&quot;;;</span><br><span class="line">        *)echo &quot;error&quot;;;</span><br><span class="line">esac</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>

<p>看起来case比较特殊，因为它不需要使用do，而是用的镜像结束符；就是in前面使用一个变量，然后in后面接上我们可能会选择的所有情况，以””)开头双分号结尾（;;）;这个变量就是我们会输入的变量；</p>
<p>for语句大致的使用还是和C语言差不多的，只是我们将大括号换成了do：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array=(&quot;Math&quot;,&quot;Chinese&quot;,&quot;Englihs&quot;,&quot;Linux&quot;)</span><br><span class="line">for item in $array</span><br><span class="line">do</span><br><span class="line">        echo $item</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>一般我们在shell需要使用in来遍历，设置一个遍历的变量，然后在do里面写打印语句或者是处理数据的代码，记得以done结尾；</p>
<p>while语句就需要一个条件来判断什么时候退出循环了，同样要使用到do：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">count=0</span><br><span class="line">read -p &quot;请输入最大值：&quot; number</span><br><span class="line">while [ $count -le $number ]</span><br><span class="line">do</span><br><span class="line">	echo $count</span><br><span class="line">	((count=count+1))</span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同样是在while的后面是用了一个方括号来进行判定，如果是判断语句出现问题的话就可能死循环了；然后使用do来表示循环的开始就可以了；</p>
<p>until其实就是while的对立面，它只有在括号里面是假的时候才会执行do里面的语句:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">count=0</span><br><span class="line">read -p &quot;请输入最大值：&quot; number</span><br><span class="line">until [ $count -ge $number ]</span><br><span class="line">do</span><br><span class="line">	echo $count</span><br><span class="line">	((count=count+1))</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>这样写就是当我们的count小于number的时候执行do里面的语句，大于number的时候就不会执行；</p>
<h4 id="6、调试脚本"><a href="#6、调试脚本" class="headerlink" title="6、调试脚本"></a>6、调试脚本</h4><p>C语言程序可以使用gdb来调试，当然shell也是不例外的，但是shell的调试要简单很多，他就只有三个：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash -n 脚本文件 #意思就是我们程序如果有错误就不会执行，只会打印错误信息，当然没错的话就执行</span><br><span class="line">bash -v  脚本文件 #意思就是打印程序执行过了得代码</span><br><span class="line">bash -x 脚本文件 #意思就是将执行的过程打印到窗口上，-v就好像打印源码，但是这个会答应每一个变量变化的过程</span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171403305.png" alt="image-20221026143323854" style="zoom:50%;" />

<p>非常详细；</p>
<h4 id="7、变量的定义和调用"><a href="#7、变量的定义和调用" class="headerlink" title="7、变量的定义和调用"></a>7、变量的定义和调用</h4><p>shell的变量定义和调用都比较简单：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">编写函数</span></span><br><span class="line">function fun()&#123;</span><br><span class="line">	local a=10</span><br><span class="line">	b=11</span><br><span class="line">	echo &quot;本地变量：&quot;$a</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">调用函数</span></span><br><span class="line">fun</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意这里的变量，我么a加了一个local修饰就表示有了作用域只可以在函数里面使用；</p>
<h3 id="11、文件操作"><a href="#11、文件操作" class="headerlink" title="11、文件操作"></a>11、文件操作</h3><p>linux中的文件操作是使用的几个系统函数来实现的，使用的是C语言，关键作用的是文件描述符，可以说操作<strong>文件描述符</strong>就是操作文件，之前我们了解过三个文件的标号，因为文件描述符也是一个类似的索引值，就是说已经有了0,1,2了，所以我们打开文件之后返回的文件描述符只能从3开始；</p>
<p>1、阅读手册，了解i&#x2F;o函数</p>
<p>在我们学习函数的使用前，最好就是阅读手册，先从头文件，然后就是函数的参数，返回值，描述。</p>
<p>输入下面的命令查看第一个i&#x2F;o函数，open</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man 2 open</span><br></pre></td></tr></table></figure>

<p>Linux的man很强大，该手册分成很多section，使用man时可以指定不同的section来浏览，各个section意义如下：<br>1 - commands<br>2 - system calls<br>3 - library calls<br>4 - special files<br>5 - file formats and convertions<br>6 - games for linux<br>7 - macro packages and conventions<br>8 - system management commands<br>9 - 其他<br>解释一下,<br>1是普通的命令<br>2是系统调用,如open,write之类的(通过这个，至少可以很方便的查到调用这个函数，需要加什么头文件)<br>3是库函数,如printf,fread<br>4是特殊文件,也就是&#x2F;dev下的各种设备文件<br>5是指文件的格式,比如passwd, 就会说明这个文件中各个字段的含义<br>6是给游戏留的,由各个游戏自己定义<br>7是附件还有一些变量,比如向environ这种全局变量在这里就有说明<br>8是系统管理用的命令,这些命令只能由root使用,如ifconfig</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171403564.png" alt="image-20221031184349852" style="zoom:50%;" />

<p>然后可以看到这样的页面，其实就是进入了手册了，先展示出来的是头文件和下面的一些函数，我们要是用他们的话这下头文件是需要导入的，这里我们可以看到第一个函数open,他需要传一个pathname，也就是文件的路径，我们可以使用一个字符数组来传递，如果是当前路径的话我们直接写文件名就行了，第二个参数就是我们要对文件进行什么操作类了，在文档后面的话都有说明，就是有一点，英文的不好阅读，都是简单词汇，有点基础的应该没有问题，这里我们一般像这样写就行了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> fb1,fb2=<span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> filename1[]=<span class="string">&quot;readtext.txt&quot;</span>;</span><br><span class="line">        <span class="type">int</span> length=<span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        fb1=open(filename1,O_RDWR|O_CREAT,<span class="number">0644</span>);</span><br><span class="line">        <span class="keyword">if</span>(fb1==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                perror(<span class="string">&quot;read open error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> filename2[]=<span class="string">&quot;writetxt.txt&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(fb2==<span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;write open error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        fb2=open(filename2,O_RDWR|O_CREAT,<span class="number">0644</span>);</span><br><span class="line">        <span class="keyword">while</span>((length=read(fb1,buf,<span class="keyword">sizeof</span>(buf)))&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                write(fb2,buf,length);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        close(fb1);</span><br><span class="line">        close(fb2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是完成一个文件复制的代码，我们来分析一下里面函数的使用，如果想要详细了解的话可以按照我们的那个指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">man 2 read </span><br><span class="line"></span><br><span class="line">man 2 write</span><br></pre></td></tr></table></figure>

<p>自行查看；</p>
<h4 id="1、open函数"><a href="#1、open函数" class="headerlink" title="1、open函数"></a>1、open函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int fb1=0;</span><br><span class="line">fb1=open(filename1,O_RDWR|O_CREAT,0644);</span><br></pre></td></tr></table></figure>

<p>这里的返回值就是一个文件描述符，是open函数的返回值，所以后面我们使用read&#x2F;write操作i&#x2F;o的时候都是操作这个文件描述符；</p>
<p>参数1是文件名，参数2是我们想要对文件的操作，这里使用的是O_RDWR（以读写方式打开）|O_CREAT（创建文件，存在文件会出错），<strong>这两者结合起来就是有文件是就以读写打开，没有文件是就创建</strong>，参数3是我们的文件权限，之前我们就说过类似的，其实文件的权限就是一个8进制的数，一个数分别对应421，可读可写可执行；一般我们会使用0644,644是对应的用户用户组和所有用户的权限；</p>
<h4 id="2、read函数"><a href="#2、read函数" class="headerlink" title="2、read函数"></a>2、read函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char buf[1024]=&#123;0&#125;;</span><br><span class="line">length=read(fb1,buf,sizeof(buf)</span><br></pre></td></tr></table></figure>

<p>文件的读写是这样的流程：读取文件时先将数据存放在缓存中，也即是这里的buf，然后读取文件的时候再从buf中读取数据，写入到目标文件中；第一个是文件描述符，也就是open的返回值，对应的就是那个文件，第二个就是缓存区，对应的就是字符数组，第三个就是长度，我们读取的话一般读取缓存区长度就行；</p>
<h4 id="3、write函数"><a href="#3、write函数" class="headerlink" title="3、write函数"></a>3、write函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fb2=open(filename2,O_RDWR|O_CREAT,0644);</span><br><span class="line">write(fb2,buf,length);</span><br></pre></td></tr></table></figure>

<p>写入文件，我们是从缓存区写入数据的，所以我们可以拿到我们存放了数据的数组buf，第一个参数同样是文件描述符，只不过是打开写入的目标文件，第二个是缓存区，第三个是长度，这里我们要以真实读取的的长度为准，所以我们拿了read的返回值，就是真实长度；</p>
<p>最后不要忘了关闭文件流：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">close(fb1);</span><br><span class="line">close(fb2);</span><br></pre></td></tr></table></figure>

<p>这个程序的逻辑也很好理解，就是我们打开要写和要读的文件，然后利用while循环读取数据然后写入到目标文件就可以了，这里就是注意一个长度的使用；</p>
<h4 id="4、lseek函数"><a href="#4、lseek函数" class="headerlink" title="4、lseek函数"></a>4、lseek函数</h4><p>这个函数跟我们的鼠标光标息息相关，他可以设置光标的起始位置，那就意味着这个函数可以决定文件复制的起始位置和写入的起始位置，同样的你可以使用man 2 lseek来查看这个函数的具体信息，这里我们就不详细说明了，我们就直接将几个重要的点提一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//设置复制起始点</span></span><br><span class="line"><span class="type">int</span> indexr=lseek(fb1,<span class="number">5</span>,SEEK_SET);</span><br><span class="line"><span class="type">int</span> indexw=lseek(fb2,<span class="number">4</span>,SEEK_SET);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个函数的第一个参数是文件描述符，也就是前面讲到的open的返回值，代表我们要移动光标的文件，第二个参数是移动的长度，如果是负数就是往前，正数就是往后，第三个就是光标的初始位置，<strong>有三个选项：SEEK_SET,SEEK_END,SEEK_CUR,其实看因为就可以知道大致的含义，第一个就是给光标设置位置，第二个就是从文件末尾开始移动，也就是光标会到文件末尾，第三个就是从光标当前位置移动；</strong>返回值就是光标前面的字节数，所以我们就可以使用lseek来算出文件的大小：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> content=lseek(fb2,<span class="number">0</span>,SEEK_END);</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171403443.png" alt="image-20221102180115928"></p>
<p>可以看到这里打印的数字就是这个写入文件的大小，这个函数也是在unistd.h头文件里面的，所以使用的时候要注意自己有没有包含它；</p>
<p>lseek还有一个功能就是可以更改文件的大小，通过插入一些“ ”，和移动光标：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lseek(fb2,100,SEEK_CUR);</span><br><span class="line">write(fb2,&quot; &quot;,1);</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171403527.png" alt="image-20221102230348019"></p>
<p>通过这个函数移动光标，从当前位置向后面移动100个单位，然后在插入空格，之前这个文件的大小事2365，如果我们执行程序将会变成2465：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171403821.png" alt="image-20221102230648188"></p>
<p>可以看到这里明显是夸大了大约100个单位，可能存在一些误差，但是无伤大雅；</p>
<h4 id="5、stat函数"><a href="#5、stat函数" class="headerlink" title="5、stat函数"></a>5、stat函数</h4><p>这个函数可以获取文件的属性，它在sys&#x2F;stat.h的文件中，我们可以使用它来获取文件属性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sbuf</span>;</span> </span><br><span class="line">result=stat(<span class="string">&quot;readtext.txt&quot;</span>,&amp;sbuf);</span><br></pre></td></tr></table></figure>

<p>这个函数具有两个参数，第一个是文件的名字，第二个参数要传一个结构体，当然这个结构体使我们自己定义的，但是函数执行成功之后它就会具有一下属性，如果执行失败的话就会返回-1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct stat &#123;</span><br><span class="line">              dev_t     st_dev;         /* ID of device containing file */</span><br><span class="line">              ino_t     st_ino;         /* Inode number */</span><br><span class="line">              mode_t    st_mode;        /* File type and mode */</span><br><span class="line">              nlink_t   st_nlink;       /* Number of hard links */</span><br><span class="line">              uid_t     st_uid;         /* User ID of owner */</span><br><span class="line">              gid_t     st_gid;         /* Group ID of owner */</span><br><span class="line">              dev_t     st_rdev;        /* Device ID (if special file) */</span><br><span class="line">              off_t     st_size;        /* Total size, in bytes */</span><br><span class="line">              blksize_t st_blksize;     /* Block size for filesystem I/O */</span><br><span class="line">              blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */</span><br><span class="line"></span><br><span class="line">              /* Since Linux 2.6, the kernel supports nanosecond</span><br><span class="line">                 precision for the following timestamp fields.</span><br><span class="line">                 For the details before Linux 2.6, see NOTES. */</span><br><span class="line"></span><br><span class="line">              struct timespec st_atim;  /* Time of last access */</span><br><span class="line">              struct timespec st_mtim;  /* Time of last modification */</span><br><span class="line">              struct timespec st_ctim;  /* Time of last status change */</span><br><span class="line"></span><br><span class="line">          #define st_atime st_atim.tv_sec      /* Backward compatibility */</span><br><span class="line">          #define st_mtime st_mtim.tv_sec</span><br><span class="line">          #define st_ctime st_ctim.tv_sec</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以我们可以写一个程序来看看文件的属性是否正确获取到了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> fd1,result=<span class="number">0</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sbuf</span>;</span></span><br><span class="line"></span><br><span class="line">        result=stat(<span class="string">&quot;readtext.txt&quot;</span>,&amp;sbuf);</span><br><span class="line">        <span class="keyword">if</span>(result==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                perror(<span class="string">&quot;stat error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;len=%1d\n&quot;</span>,sbuf.st_size);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171403204.png" alt="image-20221102181609149"></p>
<p>执行程序之后的的确确是获取到了属性的值，而且也是正确的，这里我们获取的是readtext.txt文件的长度；</p>
<h4 id="6、access函数"><a href="#6、access函数" class="headerlink" title="6、access函数"></a>6、access函数</h4><p>这个函数用来测试文件是否拥有某种权限，这个函数也是在unisted.h文件里面的，也具有两个参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">result=access(<span class="string">&quot;readtext.txt&quot;</span>,R_OK);</span><br><span class="line"><span class="keyword">if</span>(result!=<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件是可以阅读的\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件是不可以阅读的\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第一个参数是文件的路径名，第二个是权限，这里又三个可选项：R_OK, W_OK, F_OK, 他们分别代表的是文件的可读、可写、可执行，这里我们判断了一下可执行权限，执行之后是没有问题的：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171403034.png" alt="image-20221102182536747"></p>
<h4 id="7、chmod函数"><a href="#7、chmod函数" class="headerlink" title="7、chmod函数"></a>7、chmod函数</h4><p>这个函数用于修改文件的访问权限，该函数也是在sys&#x2F;stat.h文件中，他也是具有两个参数，第一个参数是文件路径名，第二个是要修改的权限，这里我们传的是一个8进制数，之前我们说过文件的权限就是一个8进制数：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171403051.png" alt="image-20221102225325415"></p>
<p>可以看到我们这里readtext文件的权限是rw-r-r，我们试着将他们改成rwx-rwx-rwx：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> result=<span class="number">0</span>;</span><br><span class="line">result=chmod(<span class="string">&quot;readtext.txt&quot;</span>,<span class="number">0777</span>);</span><br><span class="line"><span class="keyword">if</span>(result==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;this is a error\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sccessud\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们现在chmod的第一个参数上写上我们的文件名，然后第二个参数是我们想要改成的权限，这里的7就是对应的rwx，同样他也是有一个返回值得，如果调用函数失败的话就会返回一个-1：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171404356.png" alt="image-20221102225650178"></p>
<p>编译运行可以看到我们程序运行成功，再看看权限：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171404232.png" alt="image-20221102225723795"></p>
<p>很明显，这里我们的权限也是的的确确修改成功了；</p>
<h4 id="8、truncate函数"><a href="#8、truncate函数" class="headerlink" title="8、truncate函数"></a>8、truncate函数</h4><p>truncate是用来修改文件的大小的，lseek也可以修改大小，但是这个只需要调用一下就可以了，而lseek还需要写入“ ”，移动光标的操作，但是他们起到的效果是差不多的，这个函数也是具有两个参数的，第一个是文件的路径名，第二个是长度，也就是我们想要给文件设置的长度，他也是具有返回值得，如果调用失败就会返回-1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">int</span> result=<span class="number">0</span>;</span><br><span class="line"> result=truncate(<span class="string">&quot;readtext.txt&quot;</span>,<span class="number">3000</span>);</span><br><span class="line"> <span class="keyword">if</span>(result==<span class="number">-1</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sucessd&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们这是将readtext这个文件的大小设置成3000，原来的大小是2357：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171404912.png" alt="image-20221102231110661"></p>
<p>我们执行程序再来看：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171404373.png" alt="image-20221102231204385"></p>
<p>可以看到这个文件已经是修改成了3000了；</p>
<h3 id="12、进程管理"><a href="#12、进程管理" class="headerlink" title="12、进程管理"></a>12、进程管理</h3><p>在window系统上也是有一个进程管理的，也就是任务管理器，在程序中我们可以看到正在运行的进程的详细信息，并且可以筛选排序删除的操作，那么在linux上也是有这样一个程序的，进程实际上就是在运行的程序，程序没有运行的时候其实是在硬盘中的，运行的时候就是在内存；</p>
<h4 id="1、查看进程"><a href="#1、查看进程" class="headerlink" title="1、查看进程"></a>1、查看进程</h4><p>我们可以输入ps来查看当前的部分进程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps</span><br><span class="line">ps a</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171404998.png" alt="image-20221109225430561"></p>
<p>这里的a参数是罗列所有的进程的意思，这样显示出来的线程是静态的，但是罗列我们输入命令时的进程，但是进程其实是动态进行的，所以我们如果有需要动态的查看进程的话，可以使用top：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top </span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171404138.png" alt="image-20221109225600396" style="zoom:50%;" />

<p>这里top的话是直接打印了所有的进程信息，而且还是在不断变化的，可以看到很多的列，有进程号（也就是PID，相当于文件的描述符），还有user（用户，一般用来筛选），cup的使用，时间和名称等的信息，我们通过看数据也是很容易分析出来的，我们要注意一个地方就是S（进程的状态）:</p>
<p>D&#x3D;不可中断的睡眠状态<br>R&#x3D;运行<br>S&#x3D;睡眠<br>T&#x3D;跟踪&#x2F;停止<br>Z&#x3D;僵尸进程</p>
<p>这里可以看到狠毒都是s和T, 一般做服务器维护的话就要注意清理这个僵尸进程；</p>
<p>在我们输入top命令的时候其实还有很多可选项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top M(按照内存排序)/P(CPU使用排序)/T(时间排序)/K(可以根据pid杀死线程)</span><br></pre></td></tr></table></figure>

<p>如果我们打开了这个程序，就只需要输入这些可选项就可以了，程序会按照输入的内容来做出相应的操作；点击了k他就会显示一串文字：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171404239.png" alt="image-20221109230540082"></p>
<p>意思就是要我们输入要杀死的线程的pid;不过除了这种杀死线程的方式，我们还可以使用kill指令来杀死线程；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 线程PID</span><br></pre></td></tr></table></figure>

<p>这里我就不做演示了；先要退出的话直接ctrl+c，记住线程号，然后输入上面的指令就可以杀死对应的线程；</p>
<p>如果要查看当前进行中的线程，我们可以使用:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -u</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171404787.png" alt="image-20221110111609487"></p>
<h4 id="2、进程控制"><a href="#2、进程控制" class="headerlink" title="2、进程控制"></a>2、进程控制</h4><p>进程一共有四个状态：就绪态、运行态、睡眠态、终止态；这里的就绪态就是程序的资源分配到位之后等待CPU执行的状态，运行态就是cup在执行的状态，睡眠态又有阻塞态和挂起，就是一种进程因为一些原因导致无法执行的情况就阻塞，只是暂时退出但是还没有终止的进程能够随时被唤醒的状态就是挂起；</p>
<p>在linux，我们可以看到任务切换好像都是无缝的，但是从微观上来说，切换进程其实都是需要事件的，只是事件比较少，也就是说linux中的进程其实是并发的，而不是并行的；只是每个进程之间不断地切换运行我们感觉不出来而已；</p>
<h4 id="3、fork函数"><a href="#3、fork函数" class="headerlink" title="3、fork函数"></a>3、fork函数</h4><p>这个函数可以创建出一个新线程，而且这个线程的内容是和父进程一样的，我们来了解一下什么事子进程，什么父进程，在window端，如果我们用微信打开一个小程序，是不是小程序依赖着微信这个环境，我们就可以称他们为父子线程；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        pid=fork();</span><br><span class="line">        <span class="keyword">if</span>(pid==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;parent process , pid=%d,ppid=%d\n&quot;</span>,getpid(),getppid());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;parent process , pid=%d,ppid=%d\n&quot;</span>,getpid(),getppid());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;finish!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171404768.png" alt="image-20221109232409801"></p>
<p>其实这里就是父子线程打印的几句话了，这里的第二句话的ppid（也就是父进程id）就是第一句话的pin(本线程Id)，所以第一个线程就是父进程，第二个就是子进程，我们可以通过getpid、getppid来分别获取到本线程id和父线程id，不过我们通过ps现在是看不到的，因为程序执行完之后就进入了终止态；</p>
<p>这里的pid_t应该是头文件里面的宏定义，相当于int；当我们执行fork这个函数之后，就会创建一个和本线程一模一样的子线程，而且是直接执行的，所以我们要注意这个函数的使用，fork也是有返回值，这个反回值可以使0、1 、-1，分别表示的子线程、父线程、创建线程失败；如果还有不懂的话，可以使用man指令；</p>
<p>**还有一个函数是vfork()**，就是在fork的基础上加了一个特性，就是父子进程共用一块空间，我们父进程的变量在子进程中是可以改变的，</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171404894.png" alt="image-20221112202226458"></p>
<p>这个我们使用fork写的执行后的程序，现在我们换成vfork来试试：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">        pid=vfork();</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i &lt; <span class="number">2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(pid==<span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        num+=<span class="number">10</span>;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;花有重开日，人无再少年，id为：%d\n&quot;</span>,getpid());</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;增加后的num：%d\n&quot;</span>,num);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        num+=<span class="number">10</span>;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;花有重开日，人无再少年，id为：%d\n&quot;</span>,getpid());</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;增加后的num：%d\n&quot;</span>,num);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171404297.png" alt="image-20221112201953257"></p>
<p>可以看到我们这里子线程打印的num出现了一个随机数，这是因为我们复制出来的子线程共用的父线程的num，但是我们不知道何时退出子线程，所以这里就会一直进行num的累加，所以就会出现这个随机数，所以我们就需要给他一个退出的地方：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">    num+=<span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;花有重开日，人无再少年，id为：%d\n&quot;</span>,getpid());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;增加后的num：%d\n&quot;</span>,num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171404423.png" alt="image-20221112203238065"></p>
<p>这样的话我们就可以发现在子进程中退出了一次之后，我们父进程就少了一个，但是子进程是可以看到使用的是父进程的num；</p>
<h4 id="4、gdb多进程的调试"><a href="#4、gdb多进程的调试" class="headerlink" title="4、gdb多进程的调试"></a>4、gdb多进程的调试</h4><p>当我们的程序中含有父子进程的时候，我们调试可以选择父子进程还可以在两者之间切换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set detach-on-fork off/on #设置是否分离线程调试</span><br><span class="line">set follow-fork-mode parent #设置父子进程调试</span><br><span class="line">info inferiors #打印调试信息，当前调试的进程以及可调式进程</span><br><span class="line">inferior id #切换要调试的进程</span><br><span class="line">detach inferiors id #分离调试</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171404009.png" alt="image-20221112205037438"></p>
<h4 id="5、exec函数族"><a href="#5、exec函数族" class="headerlink" title="5、exec函数族"></a>5、exec函数族</h4><p>为什么叫做函数族，因为这个里面一共有6个函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">execl(文件路径名，新进程名，NULL), #在程序中插入一个新进程，这个进程会运行参数1 </span><br><span class="line">execlp(文件名，新进程名，NULL),  #与execl的作用一致，但是文件路径名会自动查找，不需要我们自己写好路径</span><br><span class="line">execle(), </span><br><span class="line">execv(), </span><br><span class="line">execvp(), </span><br><span class="line">execve()</span><br></pre></td></tr></table></figure>

<p>我们就先演示一下前面两个函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        pid_t pid;</span><br><span class="line">        int i;</span><br><span class="line">        int num=0;</span><br><span class="line">        pid=vfork();</span><br><span class="line"></span><br><span class="line">        for(i=0;i &lt; 2;i++)</span><br><span class="line">        &#123;</span><br><span class="line">                if(pid==-1)</span><br><span class="line">                &#123;</span><br><span class="line">                        perror(&quot;fork error&quot;);</span><br><span class="line">                        exit(1);</span><br><span class="line">                &#125;</span><br><span class="line">                else if(pid&gt;0)</span><br><span class="line">                &#123;</span><br><span class="line">                        num+=10;</span><br><span class="line">                        printf(&quot;花有重开日，人无再少年，id为：%d\n&quot;,getpid());</span><br><span class="line">                        printf(&quot;增加后的父线程num：%d\n&quot;,num);</span><br><span class="line">                &#125;</span><br><span class="line">                else if(pid==0)</span><br><span class="line">                &#123;</span><br><span class="line">                        num+=10;</span><br><span class="line">                        printf(&quot;花有重开日，人无再少年，id为：%d\n&quot;,getpid());</span><br><span class="line"></span><br><span class="line">                        execl(&quot;/bin/ps&quot;,&quot;ps&quot;,NULL);</span><br><span class="line">                        printf(&quot;增加后的子线程num：%d\n&quot;,num);</span><br><span class="line"></span><br><span class="line">                        exit(0);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同样是那个程序，但是我在子程序中加入了execl函数，表示的是打印ps这个shell指令，可以看到：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171404285.png" alt="image-20221112210812865"></p>
<p>有一个线程是没有打印num的值，其实使我们的子线程没有打印，因为没有了exit，但是却转向执行了ps这个指令，也是算停止了num的累加，很明显的可以看到这里的子线程其实是被execl程序中断了，相当于插入了一个进程然后不执行后面的部分了；如果我们使用excelp的话其实也是一样的效果，只不过我们可以这样用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execlp(&quot;ps&quot;,&quot;ps&quot;,NULL);</span><br></pre></td></tr></table></figure>

<h4 id="6、进程的退出"><a href="#6、进程的退出" class="headerlink" title="6、进程的退出"></a>6、进程的退出</h4><p>常见的进程退出有两种，一种是exit()，另一种叫就是_exit()，那么这两种有什么区别呢？</p>
<p>前者就是不刷新缓存区的退出，后者是会刷新缓存区的退出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        printf(&quot;hello world!\n&quot;);</span><br><span class="line">        prinft(&quot;hi&quot;);</span><br><span class="line">        exit();</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171404503.png" alt="image-20221114222347072" style="zoom:150%;" />

<p>可以看到使用exit的时候两句话都是会打印的，也就是都执行了；但是如果我们换成_exit()就不一样了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        printf(&quot;hello world!\n&quot;);</span><br><span class="line">        prinft(&quot;hi&quot;);</span><br><span class="line">        _exit(0);</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171404266.png" alt="image-20221114222508293"></p>
<h4 id="7、特殊进程"><a href="#7、特殊进程" class="headerlink" title="7、特殊进程"></a>7、特殊进程</h4><p>这里我们就讲解两个进程，<strong>一个是僵尸进程一个是孤儿进程</strong>，僵尸进程在服务器维护当中是最不应该出现的，因为会占用资源，如果线程多的话还会让电脑崩溃，所以我们就需要阻止它的产生，而孤儿进程就是没有父进程的子进程，因为父子进程是异步运行的原因，所以存在父进程提前结束的情况，而子进程就没有人关闭，于是就一直运行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">        pid=fork();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i &lt; <span class="number">2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span>(pid==<span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;parent pid:%d\n&quot;</span>,getpid());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">						sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;child pid:%d\n&quot;</span>,getpid());</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171404336.png" alt="image-20221114225253477"></p>
<p>这里我们使用了一个操作，就是在创建了子进程之后，我们让其休眠2秒，之后父进程就会退出，它退出之后子进程就成了一个孤儿进程，结果就是子进程一直在运行，没有回收，而我们可以从窗口中看到没有显示原来的那个操作界面；</p>
<p>僵尸进程就是子进程已经结束，但是父进程却一直在执行没有回收，我们可以用下面的代码看到：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">        pid=fork();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(pid==<span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">			<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line"></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;parent pid:%d\n&quot;</span>,getpid());</span><br><span class="line">				sleep(<span class="number">3</span>);</span><br><span class="line">			&#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">			sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;child pid:%d\n&quot;</span>,getpid());</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171404114.png" alt="image-20221114230111980"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171404910.png" alt="image-20221114230122645"></p>
<p>这里我们就让父线程还没有苏醒的时候让子进程结束，于是我们就可以看到图中出现了一个z+，意思就是说僵尸进程还在运行；这时候我们结束掉父进程就可以结束僵尸进程了；</p>
<p>那么我们要如何来避免僵尸进程的产生呢？linux给出了wait()函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pid_t wait(int *wstatus);</span><br><span class="line"></span><br><span class="line">pid_t waitpid(pid_t pid, int *wstatus, int options);</span><br><span class="line"></span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>wait这个函数在父进程运行的时候会进行阻塞，如果发现子进程出现了僵尸进程的话就是执行，然后回收掉他，返回这个进程的id，如果没有的话就会返回-1 ，到时候正常退出就可以了；这里的参数是用来保存进程退出是的状态信息，因为我们只是为了处理僵尸进程，所以我们一般将参数设置为null就可以了；wait的使用需要包含一个头文件sys&#x2F;wait.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;parent pid:%d\n&quot;</span>,getpid());</span><br><span class="line">			sleep(<span class="number">3</span>);</span><br><span class="line">			ret=wait(<span class="literal">NULL</span>);</span><br><span class="line">			<span class="keyword">if</span>(ret==<span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(ret&gt;<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;处理了一个僵尸进程！%d\n&quot;</span>,ret);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们在父进程的while循环里面添加这样的代码，然后结果就会截然不同：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//android-imges/202211171404441.png" alt="image-20221114231533770"></p>
<p>原本会一直执行下去的父进程随着僵尸进程的产生随之就是退出了，是因为wait函数的调用，在产生了僵尸进程时候进行了处理然后打印了2099的编号，然后在没有了僵尸进程时候就执行了exit(0);</p>
<p>waitpid这个函数可以说是wait的升级版，他有三个参数，可以设置参数pid为-1，那么他的作用就是和wait一样的，他的显著特点就是不会阻塞线程，也就是在父进程运行的时候处理的子进程；</p>
<h4 id="8、进程之间的通讯"><a href="#8、进程之间的通讯" class="headerlink" title="8、进程之间的通讯"></a>8、进程之间的通讯</h4><p>进程之间是独立的，但是又是有联系的，他们可以使用管道、信号、socket、消息队列和共享内存来实现通信，那么我们先来看看进程之间如何使用管道通讯：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        pid_t pid;</span><br><span class="line">        int fd[2];</span><br><span class="line">        int ret=pipe(fd);</span><br><span class="line">        if(ret==-1)</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;pipe error!\n&quot;);</span><br><span class="line">                exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        pid=fork();</span><br><span class="line">        if(pid==-1)</span><br><span class="line">        &#123;</span><br><span class="line">                perror(&quot;fork error\n&quot;);</span><br><span class="line">                exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(pid&gt;0)</span><br><span class="line">        &#123;</span><br><span class="line">                        waitpid(pid,NULL,WNOHANG);</span><br><span class="line">                        close(fd[1]);</span><br><span class="line">                        char buf[1024]=&#123;0&#125;;</span><br><span class="line">                        int len=0;</span><br><span class="line">                        len=read(fd[0],buf,sizeof(buf));</span><br><span class="line">                        printf(&quot;parent receive meassge:%s\n&quot;,buf);</span><br><span class="line">                        close(fd[0]);</span><br><span class="line">                        sleep(2);</span><br><span class="line">        &#125; </span><br><span class="line">        else if(pid==0)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">                        close(0);</span><br><span class="line">                        char * str=&quot;this is a message by child send!\n&quot;;</span><br><span class="line">                        write(fd[1],str,strlen(str)+1);</span><br><span class="line">                        close(fd[1]);</span><br><span class="line">                        sleep(2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line">                                                                                                            </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>要注意几个点，管道是需要在进程创建之前在再创建的，如果在进程之后创建管道的话顺序就乱了，管道将不会生效，而且这个半双工过程，也就说我们一次只能通信一次，要么是a向b发信息，要么就是b向a，不能ab同时，所以我这里就拿父子进程来讲解；</p>
<p>首先我们创建管道：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int fd[2];</span><br><span class="line">int ret=pipe(fd);</span><br></pre></td></tr></table></figure>

<p>他需要一个int数组，两个元素，一个是读端（fd[0]）一个是写端(fd[1])，pipe这个函数就是用来创建管道的，他的参数就是这个数组；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">close(fd[1]);</span><br><span class="line">char buf[1024]=&#123;0&#125;;</span><br><span class="line">int len=0;</span><br><span class="line">len=read(fd[0],buf,sizeof(buf));</span><br><span class="line">printf(&quot;parent receive meassge:%s\n&quot;,buf);</span><br><span class="line">close(fd[0]);</span><br><span class="line">sleep(2);</span><br></pre></td></tr></table></figure>

<p>在我们要写或者读一个内容的时候，如果是写我们就应该把读的管道描述符关闭，也就是这里的fd[0]，同理如果是读的话就是关闭写了；</p>
<p>使用读写流也是read和write之前我讲过的，参数的话第一个就是描述符，第二个就是数据，第三个就是长度，这里注意read的返回值是读取到的真实长度，如果读取失败的话就是返回-1；如果想要父子之间一直保持通讯的话我们就不能关闭读写流了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        pid_t pid;</span><br><span class="line">	int fd[2];</span><br><span class="line">	int ret=pipe(fd);</span><br><span class="line">	if(ret==-1)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;pipe error!\n&quot;);</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	pid=fork();</span><br><span class="line">        if(pid==-1)</span><br><span class="line">        &#123;</span><br><span class="line">                perror(&quot;fork error\n&quot;);</span><br><span class="line">                exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(pid&gt;0)</span><br><span class="line">        &#123;</span><br><span class="line">		char buf[1024]=&#123;0&#125;;</span><br><span class="line">		while(1)</span><br><span class="line">		&#123;</span><br><span class="line">			waitpid(pid,NULL,WNOHANG);</span><br><span class="line">			int len=0;</span><br><span class="line">			len=read(fd[0],buf,sizeof(buf));</span><br><span class="line">			printf(&quot;parent receive meassge:%s\n&quot;,buf);</span><br><span class="line">			sleep(2);</span><br><span class="line">			char * str = &quot;fighing ,child ,you are my hope!\n&quot;;</span><br><span class="line">			write(fd[1],str,strlen(str)+1);</span><br><span class="line">			sleep(2);</span><br><span class="line">		&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(pid==0)</span><br><span class="line">        </span><br><span class="line">	&#123;</span><br><span class="line">		char buf[1024]=&#123;0&#125;;</span><br><span class="line">		while(1)</span><br><span class="line">		&#123;</span><br><span class="line">			char * str=&quot;fighting , parent , you are my example!\n&quot;;</span><br><span class="line">			write(fd[1],str,strlen(str)+1);</span><br><span class="line">			sleep(2);</span><br><span class="line">			int len=0;</span><br><span class="line">			len = read(fd[0],buf,sizeof(buf));</span><br><span class="line">			sleep(2);</span><br><span class="line">			printf(&quot;child receive message:%s\n&quot;,buf);</span><br><span class="line">		&#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://tony-hurry.github.io/tony.github.io">Tony</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://tony-hurry.github.io/tony.github.io/2022/09/11/Linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/">https://tony-hurry.github.io/tony.github.io/2022/09/11/Linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tony.github.io/tags/Linux%E5%AD%A6%E4%B9%A0/">Linux学习</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//study-images/linux.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/tony.github.io/2022/09/11/android/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//study-images/android.png" onerror="onerror=null;src='/tony.github.io/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Android high learning</div></div></a></div><div class="next-post pull-right"><a href="/tony.github.io/2022/08/29/python-baselearning/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//study-images/python.png" onerror="onerror=null;src='/tony.github.io/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">python-baselearning</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/tony.github.io/img/head.gif" onerror="this.onerror=null;this.src='/tony.github.io/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Tony</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/tony.github.io/archives/"><div class="headline">Articles</div><div class="length-num">6</div></a><a href="/tony.github.io/tags/"><div class="headline">Tags</div><div class="length-num">4</div></a><a href="/tony.github.io/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Tony-hurry"><i class="fab fa-github"></i><span>本座</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Tony-hurry" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">欢迎大学阅读！乘风破浪会有时，直挂云帆济沧海。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.</span> <span class="toc-text">Linux基础学习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BD%BF%E7%94%A8xshell%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6Linux"><span class="toc-number">1.0.1.</span> <span class="toc-text">1、使用xshell远程控制Linux</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4"><span class="toc-number">1.0.2.</span> <span class="toc-text">2、Linux基本操作指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%9D%83%E9%99%90%E5%B8%B8%E8%AF%86"><span class="toc-number">1.0.3.</span> <span class="toc-text">3、权限常识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E4%BF%AE%E6%94%B9%E6%9D%83%E9%99%90"><span class="toc-number">1.0.3.1.</span> <span class="toc-text">1、修改权限</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81vi%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.0.4.</span> <span class="toc-text">4、vi编辑器的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E7%BC%96%E8%BE%91"><span class="toc-number">1.0.4.1.</span> <span class="toc-text">1、编辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E7%BC%96%E8%AF%91"><span class="toc-number">1.0.4.2.</span> <span class="toc-text">2、编译</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E6%B3%A8%E6%84%8F"><span class="toc-number">1.0.4.3.</span> <span class="toc-text">3、注意</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E9%A6%96%E6%AC%A1%E7%99%BB%E9%99%86%E7%AE%A1%E7%90%86%E5%91%98"><span class="toc-number">1.0.5.</span> <span class="toc-text">5、首次登陆管理员</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81"><span class="toc-number">1.0.5.1.</span> <span class="toc-text">1、设置密码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E6%9B%B4%E6%96%B0vi%E7%BC%96%E8%BE%91%E5%99%A8"><span class="toc-number">1.0.5.2.</span> <span class="toc-text">2、更新vi编辑器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F%EF%BC%88gdb-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.0.6.</span> <span class="toc-text">6、调试程序（gdb)的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84"><span class="toc-number">1.0.7.</span> <span class="toc-text">7、用户和用户组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%EF%BC%9A"><span class="toc-number">1.0.7.1.</span> <span class="toc-text">1、创建用户：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E7%BB%99%E7%94%A8%E6%88%B7%E5%88%86%E7%BB%84"><span class="toc-number">1.0.7.2.</span> <span class="toc-text">2、给用户分组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E7%BB%84"><span class="toc-number">1.0.7.3.</span> <span class="toc-text">3、创建一个用户组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E6%9D%83%E9%99%90%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="toc-number">1.0.7.4.</span> <span class="toc-text">4、权限的修改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84"><span class="toc-number">1.0.7.5.</span> <span class="toc-text">5、删除用户和用户组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81shell%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8"><span class="toc-number">1.0.8.</span> <span class="toc-text">8、shell基础入门</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E9%87%8D%E5%AE%9A%E5%90%91%E3%80%81%E7%AE%A1%E9%81%93%E3%80%81%E8%BF%9E%E6%8E%A5%E7%AC%A6%E5%92%8C%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90%E5%99%A8%EF%BC%88awk%EF%BC%89"><span class="toc-number">1.0.8.1.</span> <span class="toc-text">1、重定向、管道、连接符和文本分析器（awk）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91%EF%BC%9A"><span class="toc-number">1.0.8.1.1.</span> <span class="toc-text">1、输出重定向：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E8%BE%93%E5%85%A5%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">1.0.8.1.2.</span> <span class="toc-text">2、输入重定向</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E9%94%99%E8%AF%AF%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">1.0.8.1.3.</span> <span class="toc-text">3、错误重定向</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E7%AE%A1%E9%81%93"><span class="toc-number">1.0.8.1.4.</span> <span class="toc-text">4、管道</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E8%BF%9E%E6%8E%A5%E7%AC%A6"><span class="toc-number">1.0.8.1.5.</span> <span class="toc-text">5、连接符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90%E5%99%A8awk"><span class="toc-number">1.0.8.1.6.</span> <span class="toc-text">6、文本分析器awk</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAshell%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.0.8.2.</span> <span class="toc-text">2、第一个shell程序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E6%9B%B4%E6%8D%A2%E8%BE%93%E5%85%A5%E6%B3%95"><span class="toc-number">1.0.9.</span> <span class="toc-text">9、更换输入法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8"><span class="toc-number">1.0.10.</span> <span class="toc-text">10、shell编程基础入门</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">1.0.10.1.</span> <span class="toc-text">1、变量定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E8%AE%A1%E7%AE%97%E5%BC%8F"><span class="toc-number">1.0.10.2.</span> <span class="toc-text">2、计算式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.0.10.3.</span> <span class="toc-text">3、判断语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81read%E6%8E%A5%E5%8F%97%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5"><span class="toc-number">1.0.10.4.</span> <span class="toc-text">4、read接受用户输入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81selecte%E3%80%81case%E3%80%81for%E3%80%81while%E3%80%81until%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">1.0.10.5.</span> <span class="toc-text">5、selecte、case、for、while、until语句的基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E8%B0%83%E8%AF%95%E8%84%9A%E6%9C%AC"><span class="toc-number">1.0.10.6.</span> <span class="toc-text">6、调试脚本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8"><span class="toc-number">1.0.10.7.</span> <span class="toc-text">7、变量的定义和调用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">1.0.11.</span> <span class="toc-text">11、文件操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81open%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.11.1.</span> <span class="toc-text">1、open函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81read%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.11.2.</span> <span class="toc-text">2、read函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81write%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.11.3.</span> <span class="toc-text">3、write函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81lseek%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.11.4.</span> <span class="toc-text">4、lseek函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81stat%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.11.5.</span> <span class="toc-text">5、stat函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81access%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.11.6.</span> <span class="toc-text">6、access函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81chmod%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.11.7.</span> <span class="toc-text">7、chmod函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81truncate%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.11.8.</span> <span class="toc-text">8、truncate函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">1.0.12.</span> <span class="toc-text">12、进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.0.12.1.</span> <span class="toc-text">1、查看进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">1.0.12.2.</span> <span class="toc-text">2、进程控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81fork%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.12.3.</span> <span class="toc-text">3、fork函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81gdb%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B0%83%E8%AF%95"><span class="toc-number">1.0.12.4.</span> <span class="toc-text">4、gdb多进程的调试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81exec%E5%87%BD%E6%95%B0%E6%97%8F"><span class="toc-number">1.0.12.5.</span> <span class="toc-text">5、exec函数族</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%80%E5%87%BA"><span class="toc-number">1.0.12.6.</span> <span class="toc-text">6、进程的退出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81%E7%89%B9%E6%AE%8A%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.0.12.7.</span> <span class="toc-text">7、特殊进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E8%AE%AF"><span class="toc-number">1.0.12.8.</span> <span class="toc-text">8、进程之间的通讯</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/tony.github.io/2022/11/05/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%B6%E4%BD%9C/" title="No title"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img1.baidu.com/it/u=4275188472,2391919813&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=500" onerror="this.onerror=null;this.src='/tony.github.io/img/404.jpg'" alt="No title"/></a><div class="content"><a class="title" href="/tony.github.io/2022/11/05/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%88%B6%E4%BD%9C/" title="No title">No title</a><time datetime="2022-11-05T01:10:53.268Z" title="Created 2022-11-05 09:10:53">2022-11-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/tony.github.io/2022/10/15/vue%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" title="No title"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img1.baidu.com/it/u=4275188472,2391919813&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=500" onerror="this.onerror=null;this.src='/tony.github.io/img/404.jpg'" alt="No title"/></a><div class="content"><a class="title" href="/tony.github.io/2022/10/15/vue%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" title="No title">No title</a><time datetime="2022-10-15T01:48:14.079Z" title="Created 2022-10-15 09:48:14">2022-10-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/tony.github.io/2022/09/11/android/" title="Android high learning"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//study-images/android.png" onerror="this.onerror=null;this.src='/tony.github.io/img/404.jpg'" alt="Android high learning"/></a><div class="content"><a class="title" href="/tony.github.io/2022/09/11/android/" title="Android high learning">Android high learning</a><time datetime="2022-09-11T01:52:11.000Z" title="Created 2022-09-11 09:52:11">2022-09-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/tony.github.io/2022/09/11/Linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/" title="Linux base"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//study-images/linux.png" onerror="this.onerror=null;this.src='/tony.github.io/img/404.jpg'" alt="Linux base"/></a><div class="content"><a class="title" href="/tony.github.io/2022/09/11/Linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/" title="Linux base">Linux base</a><time datetime="2022-09-11T01:52:11.000Z" title="Created 2022-09-11 09:52:11">2022-09-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/tony.github.io/2022/08/29/python-baselearning/" title="python-baselearning"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//study-images/python.png" onerror="this.onerror=null;this.src='/tony.github.io/img/404.jpg'" alt="python-baselearning"/></a><div class="content"><a class="title" href="/tony.github.io/2022/08/29/python-baselearning/" title="python-baselearning">python-baselearning</a><time datetime="2022-08-28T23:06:27.000Z" title="Created 2022-08-29 07:06:27">2022-08-29</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/Tony-hurry/imageBad@main//study-images/linux.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Tony</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/tony.github.io/js/utils.js"></script><script src="/tony.github.io/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>